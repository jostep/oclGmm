!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
.DEFAULT_GOAL	Makefile	/^.DEFAULT_GOAL := all$/;"	m
ALIGNUP	core.h	154;"	d
BLOCKIDX	core.h	151;"	d
BLOCKMASK	core.h	147;"	d
BLOCKSHIFT	core.h	146;"	d
BLOCKSIZE	core.h	145;"	d
BLOCKUP	core.h	152;"	d
BUFSIZE	core.h	102;"	d
CC	Makefile	/^CC := gcc$/;"	m
CFLAGS	Makefile	/^CFLAGS := -g -Wall -pthread -fPIC -fvisibility=hidden \\$/;"	m
CUDAPATH	Makefile	/^CUDAPATH = \/usr\/local\/cuda$/;"	m
DEBUG	common.h	14;"	d
ERROR	common.h	11;"	d
FALSE	oclTest/newT.c	9;"	d	file:
FALSE	oclTest/test.c	9;"	d	file:
FATAL	common.h	10;"	d
FLAG_COW	hint.h	20;"	d
FLAG_MEMSET	hint.h	24;"	d
FLAG_PRINT_BUFFER	Makefile	/^FLAG_PRINT_BUFFER := -DGMM_PRINT_BUFFER$/;"	m
FLAG_PRINT_BUFFER	Makefile	/^FLAG_PRINT_BUFFER :=$/;"	m
GBUFFER_SIZE	common.c	35;"	d	file:
GMM_BUFFER_COW	hint.h	22;"	d
GMM_CONFIGS	gmm.mk	/^GMM_CONFIGS :=$/;"	m
GMM_EXPORT	common.h	7;"	d
GMM_PRINT_LEVEL	common.h	18;"	d
GMM_PRINT_MSG	common.c	/^char *GMM_PRINT_MSG[PRINT_LEVELS] = {$/;"	v
GMM_SEM_LAUNCH	protocol.h	74;"	d
GMM_SHM_GLOBAL	protocol.h	75;"	d
HINT_DEFAULT	hint.h	9;"	d
HINT_INPUT	hint.h	6;"	d
HINT_MASK	hint.h	10;"	d
HINT_OUTPUT	hint.h	8;"	d
HINT_PTADEFAULT	hint.h	17;"	d
HINT_PTAMASK	hint.h	18;"	d
HINT_PTAREAD	hint.h	15;"	d
HINT_PTARRAY	hint.h	14;"	d
HINT_PTAWRITE	hint.h	16;"	d
HINT_READ	hint.h	5;"	d
HINT_WRITE	hint.h	7;"	d
ILIST_ADD	protocol.h	/^static inline void ILIST_ADD(struct gmm_global *p, int inew)$/;"	f
ILIST_DEL	protocol.h	/^static inline void ILIST_DEL(struct gmm_global *p, int idel)$/;"	f
ILIST_MOV	protocol.h	/^static inline void ILIST_MOV(struct gmm_global *p, int imov)$/;"	f
INFO	common.h	13;"	d
INIT_LIST_HEAD	list.h	/^static inline void INIT_LIST_HEAD(struct list_head *list)$/;"	f
INTERCEPT_CL	interfaces.h	33;"	d
LDFLAGS	Makefile	/^LDFLAGS := -shared -pthread -ldl -fPIC -OpenCL$/;"	m
LIBGMM	Makefile	/^LIBGMM = libgmm.so$/;"	m
LMAX	core.c	/^long LMAX(long a, long b)$/;"	f
LOWER_PAGE	core.h	141;"	d
MAX_SOURCE_SIZE	oclTest/newT.c	12;"	d	file:
MAX_SOURCE_SIZE	oclTest/test.c	12;"	d	file:
MEM_SIZE	oclTest/newT.c	11;"	d	file:
MEM_SIZE	oclTest/test.c	11;"	d	file:
MIN	core.h	143;"	d
MSG_REP_ACK	protocol.h	/^	MSG_REP_ACK,$/;"	e	enum:msgtype
MSG_REQ_EVICT	protocol.h	/^	MSG_REQ_EVICT,$/;"	e	enum:msgtype
NBUFS	core.h	101;"	d
NCLIENTS	protocol.h	12;"	d
NRBLOCKS	core.h	150;"	d
NREFS	core.h	66;"	d
OBJS	Makefile	/^OBJS = $(SRCS:.c=.o)$/;"	m
OFFSETOF	list.h	90;"	d
OPENCL_PATH	interfaces.h	16;"	d
PAGEMASK	core.h	139;"	d
PRINT_LEVEL	gmm.mk	/^PRINT_LEVEL = 6$/;"	m
PRINT_LEVELS	common.h	15;"	d
PRIO_DEFAULT	hint.h	28;"	d
PRIO_LOWEST	hint.h	27;"	d
SRCS	Makefile	/^SRCS = client.c common.c core.c interfaces.c msq.c replacement.c stats.c debug.c$/;"	m
STAT	common.h	9;"	d
STATE_ATTACHED	core.h	/^	STATE_ATTACHED,			\/\/ object allocated with device memory$/;"	e	enum:region_state
STATE_DETACHED	core.h	/^	STATE_DETACHED = 0,		\/\/ object not allocated with device memory$/;"	e	enum:region_state
STATE_EVICTING	core.h	/^	STATE_EVICTING,			\/\/ object being evicted$/;"	e	enum:region_state
STATE_FREEING	core.h	/^	STATE_FREEING,			\/\/ object being freed$/;"	e	enum:region_state
STATE_ZOMBIE	core.h	/^	STATE_ZOMBIE			\/\/ object waiting to be GC'ed$/;"	e	enum:region_state
TDIFF	stats.h	53;"	d
TREAT_ERROR	interfaces.h	18;"	d
TRUE	oclTest/newT.c	10;"	d	file:
TRUE	oclTest/test.c	10;"	d	file:
TRY_ACQUIRE_TIMES	spinlock.h	42;"	d
TVAL	stats.h	52;"	d
UPPER_PAGE	core.h	140;"	d
USE_PRINT_BUFFER	gmm.mk	/^USE_PRINT_BUFFER = 0$/;"	m
WARN	common.h	12;"	d
_GMM_ATOMIC_H_	atomic.h	2;"	d
_GMM_CLIENT_H_	client.h	2;"	d
_GMM_COMMON_H_	common.h	2;"	d
_GMM_CORE_H_	core.h	2;"	d
_GMM_DEBUG_H_	debug.h	2;"	d
_GMM_HINT_H_	hint.h	2;"	d
_GMM_H_	gmm.h	3;"	d
_GMM_INTERFACES_H_	interfaces.h	2;"	d
_GMM_LIST_H_	list.h	2;"	d
_GMM_MSQ_H_	msq.h	2;"	d
_GMM_PROTOCOL_H_	protocol.h	4;"	d
_GMM_REPLACEMENT_H_	replacement.h	2;"	d
_GMM_SPINLOCK_H_	spinlock.h	3;"	d
_GMM_STATS_H_	stats.h	2;"	d
_GNU_SOURCE	common.h	60;"	d
__USE_GNU	interfaces.h	5;"	d
__list_add	list.h	/^static inline void __list_add($/;"	f
__list_del	list.h	/^static inline void __list_del(struct list_head * prev, struct list_head * next)$/;"	f
ack	msq.c	/^long ack = 0;	\/\/ it's meaning depends on the message;$/;"	v
acquire	spinlock.h	/^static inline void acquire(struct spinlock *lk)$/;"	f
arg	core.h	/^	void *arg;$/;"	m	struct:ndptr_arg
arg	core.h	/^	} arg;$/;"	m	struct:karg	typeref:union:karg::__anon1
arg1	core.h	/^		struct dptr_arg arg1;$/;"	m	union:karg::__anon1	typeref:struct:karg::__anon1::dptr_arg
arg2	core.h	/^		struct ndptr_arg arg2;$/;"	m	union:karg::__anon1	typeref:struct:karg::__anon1::ndptr_arg
argoff	core.h	/^	size_t argoff;$/;"	m	struct:karg
atomic_add	atomic.h	/^static inline int atomic_add(atomic_t *ptr, int val)$/;"	f
atomic_dec	atomic.h	/^static inline int atomic_dec(atomic_t *ptr)$/;"	f
atomic_inc	atomic.h	/^static inline int atomic_inc(atomic_t *ptr)$/;"	f
atomic_read	atomic.h	/^static inline int atomic_read(atomic_t *ptr)$/;"	f
atomic_set	atomic.h	/^static inline void atomic_set(atomic_t *ptr, int val)$/;"	f
atomic_sub	atomic.h	/^static inline int atomic_sub(atomic_t *ptr, int val)$/;"	f
atomic_t	atomic.h	/^typedef volatile int atomic_t;$/;"	t
begin_dma	core.c	/^static void begin_dma(struct dma_channel *chan){$/;"	f	file:
block	core.h	/^struct block {$/;"	s
block	protocol.h	/^	int block;$/;"	m	struct:msg_req
block_sync	core.c	/^static int block_sync(struct region *r, int block)$/;"	f	file:
blocks	core.h	/^	struct block *blocks;	\/\/ device memory blocks$/;"	m	struct:region	typeref:struct:region::block
bytes_d2s	stats.h	/^	long bytes_d2s;				\/\/ device to swap buffer$/;"	m	struct:statistics
bytes_dtod	stats.h	/^	long bytes_dtod;			\/\/ # of bytes going through the dtod API$/;"	m	struct:statistics
bytes_dtoh	stats.h	/^	long bytes_dtoh;			\/\/ # of bytes going through the dtoh API$/;"	m	struct:statistics
bytes_evict_needed	stats.h	/^	long bytes_evict_needed;	\/\/ # of bytes of free space required$/;"	m	struct:statistics
bytes_evict_space	stats.h	/^	long bytes_evict_space;		\/\/ # of bytes actually freed$/;"	m	struct:statistics
bytes_htod	stats.h	/^	long bytes_htod;			\/\/ # of bytes going through the htod API$/;"	m	struct:statistics
bytes_htod_cow	stats.h	/^	long bytes_htod_cow;		\/\/ # of htod bytes that are marked cow$/;"	m	struct:statistics
bytes_mem_active	stats.c	/^long bytes_mem_active = 0L;$/;"	v
bytes_mem_alloc	stats.h	/^	long bytes_mem_alloc;		\/\/ # of bytes allocated$/;"	m	struct:statistics
bytes_mem_freed	stats.h	/^	long bytes_mem_freed;		\/\/ # of bytes explicitly freed (detect leaks)$/;"	m	struct:statistics
bytes_mem_peak	stats.h	/^	long bytes_mem_peak;		\/\/ # of bytes held at peak$/;"	m	struct:statistics
bytes_memset	stats.h	/^	long bytes_memset;			\/\/ # of bytes going through the memset API$/;"	m	struct:statistics
bytes_s2d	stats.h	/^	long bytes_s2d;				\/\/ swap buffer to device$/;"	m	struct:statistics
bytes_s2u	stats.h	/^	long bytes_s2u;				\/\/ swap buffer to user buffer$/;"	m	struct:statistics
bytes_u2d	stats.h	/^	long bytes_u2d;				\/\/ user buffer to device, i.e. cow loading$/;"	m	struct:statistics
bytes_u2s	stats.h	/^	long bytes_u2s;				\/\/ user buffer to swap buffer$/;"	m	struct:statistics
cid	client.c	/^int cid = -1;						\/\/ Id of this client$/;"	v
cidtopid	client.c	/^pid_t cidtopid(int cid)$/;"	f
clBuildProgram	interfaces.c	/^cl_int clBuildProgram(cl_program program, cl_uint num_devices, const cl_device_id* devices, const char *options, void (*pfn_notify)(cl_program,void*user_data),void*user_data){$/;"	f
clCreateBuffer	interfaces.c	/^cl_mem clCreateBuffer(cl_context context, cl_mem_flags flags, size_t size, void *host_ptr, cl_int *errcode){$/;"	f
clCreateContext	interfaces.c	/^cl_context clCreateContext(const cl_context_properties *properties,cl_uint num_devices,const cl_device_id *devices,void (CL_CALLBACK* pfn_notify)(const char *errinfo, const void *private_info, size_t cb, void *user_data), void *user_data,cl_int *errcode_ret){$/;"	f
clCreateProgramWithSource	interfaces.c	/^cl_program clCreateProgramWithSource(cl_context context, cl_uint count, const char** strings, const size_t *lengths, cl_int *errcode_ret){$/;"	f
clEnqueueCopyBuffer	interfaces.c	/^cl_int clEnqueueCopyBuffer(cl_command_queue command_queue,cl_mem src,cl_mem dst, size_t src_off,size_t dst_off, size_t cb, cl_uint num_events_in_wait_list,const cl_event* event_wait_list,cl_event* event){$/;"	f
clEnqueueFillBuffer	interfaces.c	/^cl_int clEnqueueFillBuffer(cl_command_queue command_queue, cl_mem buffer, const void *pattern, size_t pattern_size, size_t offset,size_t size, cl_uint num_events_in_wait_list,const cl_event *event_wait_list, cl_event * event){$/;"	f
clEnqueueNDRangeKernel	interfaces.c	/^cl_int clEnqueueNDRangeKernel(cl_command_queue command_queue,cl_kernel kernel,cl_uint work_dim,const size_t* global_work_offset, const size_t* global_work_size,const size_t* local_work_size,cl_uint num_events, const cl_event* events_wait_list, cl_event* event){$/;"	f
clEnqueueReadBuffer	interfaces.c	/^cl_int clEnqueueReadBuffer(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_read, size_t offset, size_t cb, void * ptr, cl_uint num_events_in_wait_list, const cl_event *events_wait_list, cl_event *event){$/;"	f
clEnqueueTask	interfaces.c	/^cl_int clEnqueueTask(cl_command_queue command_queue, cl_kernel kernel, cl_uint num_events, const cl_event * events_wait_list, cl_event* event){$/;"	f
clEnqueueWriteBuffer	interfaces.c	/^cl_int clEnqueueWriteBuffer(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_write, $/;"	f
clReference	interfaces.c	/^cl_int clReference(int which_arg, int flags){$/;"	f
clReleaseMemObject	interfaces.c	/^cl_int clReleaseMemObject(cl_mem memObj){$/;"	f
clSetKernelArg	interfaces.c	/^cl_int clSetKernelArg(cl_kernel kernel, cl_uint arg_index,size_t arg_size, const void* arg_value){$/;"	f
client	core.h	/^	int client;				\/\/ for a remote victim$/;"	m	struct:victim
client_alloc	client.c	/^static int client_alloc()$/;"	f	file:
client_attach	client.c	/^int client_attach()$/;"	f
client_detach	client.c	/^void client_detach() {$/;"	f
client_free	client.c	/^static void client_free(int id)$/;"	f	file:
client_lru_detachable	client.c	/^int client_lru_detachable()$/;"	f
client_unpin	client.c	/^void client_unpin(int client)$/;"	f
clients	protocol.h	/^	struct gmm_client clients[NCLIENTS];$/;"	m	struct:gmm_global	typeref:struct:gmm_global::gmm_client
commandQueue_chan	core.h	/^    cl_command_queue commandQueue_chan;$/;"	m	struct:dma_channel
commandQueue_kernel	core.h	/^    cl_command_queue commandQueue_kernel;$/;"	m	struct:gmm_context
cond_ack	msq.c	/^pthread_cond_t cond_ack;$/;"	v
context_kernel	core.h	/^    cl_context context_kernel;$/;"	m	struct:gmm_context
corun	oclTest/newT.c	14;"	d	file:
corun	oclTest/test.c	14;"	d	file:
count_attach_fail	stats.h	/^	long count_attach_fail;		\/\/ # of failed attach$/;"	m	struct:statistics
count_evict_fail	stats.h	/^	long count_evict_fail;		\/\/ # of failed evictions in gmm_evict$/;"	m	struct:statistics
count_evict_victims	stats.h	/^	long count_evict_victims;	\/\/ # of evicted victim regions$/;"	m	struct:statistics
cudaMemcpyHostToDeviceCow	hint.h	21;"	d
dev_addr	core.h	/^	cl_mem dev_addr;			\/\/ device memory address$/;"	m	struct:region
dev_valid	core.h	/^	int dev_valid;			\/\/ if data copy on device is valid$/;"	m	struct:block
device	core.h	/^    cl_device_id * device;$/;"	m	struct:gmm_context
dma_channel	core.h	/^struct dma_channel {$/;"	s
dma_channel_fini	core.c	/^static void dma_channel_fini(struct dma_channel *chan){$/;"	f	file:
dma_channel_init	core.c	/^static int dma_channel_init(struct gmm_context *ctx,struct dma_channel *chan, int htod){$/;"	f	file:
dma_dtoh	core.h	/^	struct dma_channel dma_dtoh;		\/\/ DtoH DMA channel$/;"	m	struct:gmm_context	typeref:struct:gmm_context::dma_channel
dma_htod	core.h	/^	struct dma_channel dma_htod;		\/\/ HtoD DMA channel$/;"	m	struct:gmm_context	typeref:struct:gmm_context::dma_channel
dptr	core.h	/^	cl_mem  dptr;				\/\/ the actual device memory address$/;"	m	struct:dptr_arg
dptr_arg	core.h	/^struct dptr_arg {$/;"	s
end_dma	core.c	/^static void end_dma(struct dma_channel *chan){$/;"	f	file:
entry	core.h	/^	struct list_head entry;$/;"	m	struct:victim	typeref:struct:victim::list_head
entry_alloced	core.h	/^	struct list_head entry_alloced;		\/\/ linked to the list of allocated$/;"	m	struct:region	typeref:struct:region::list_head
entry_attached	core.h	/^	struct list_head entry_attached;	\/\/ linked to the list of attached$/;"	m	struct:region	typeref:struct:region::list_head
event_kernel	core.h	/^    cl_event event_kernel;$/;"	m	struct:gmm_context
events	core.h	/^	cl_event events[NBUFS];	\/\/ Events for syncing staging buffers$/;"	m	struct:dma_channel
flags	core.h	/^	int flags;				\/\/ RW hints$/;"	m	struct:dptr_arg
flags	core.h	/^	int flags;$/;"	m	struct:rwhint
flags	core.h	/^	int flags[NREFS];			\/\/ is each region read\/modified by the kernel?$/;"	m	struct:kcb
flags	core.h	/^    cl_mem_flags flags;$/;"	m	struct:region
from	protocol.h	/^	int from;$/;"	m	struct:msg_rep
from	protocol.h	/^	int from;$/;"	m	struct:msg_req
getcid	client.c	/^int getcid()$/;"	f
gettid	common.h	/^static inline pid_t gettid()$/;"	f
gmm_attach	core.c	/^static int gmm_attach(struct region **rgns, int n)$/;"	f	file:
gmm_clBuildProgram	core.c	/^cl_int gmm_clBuildProgram(cl_program program,cl_uint num_devices, const cl_device_id *devices_list,const char *options,void(*pfn_notify)(cl_program, void* user_data),void * user_data){$/;"	f
gmm_clCreateBuffer	core.c	/^cl_mem gmm_clCreateBuffer(cl_context context, cl_mem_flags flags, size_t size, void *host_ptr, cl_int* errcode_CB, int gmm_flags){$/;"	f
gmm_clCreateContext	core.c	/^cl_context gmm_clCreateContext(cl_context_properties *properties,cl_uint num_devices,const cl_device_id *devices,void *pfn_notify (const char *errinfo, const void *private_info, size_t cb, void *user_data), void *user_data,cl_int *errcode_ret){$/;"	f
gmm_clCreateProgramWithSource	core.c	/^cl_program gmm_clCreateProgramWithSource(cl_context context, cl_uint count, const char**strings, const size_t * lengths, cl_int *errcode_ret){$/;"	f
gmm_clEnqueueCopyBuffer	core.c	/^cl_int  gmm_clEnqueueCopyBuffer(cl_command_queue command_queue,cl_mem src,cl_mem dst,size_t src_off,size_t dst_off,size_t count,cl_uint num_events_in_wait_list,const cl_event* event_wait_list,cl_event* event)$/;"	f
gmm_clEnqueueFillBuffer	core.c	/^cl_int gmm_clEnqueueFillBuffer(cl_command_queue command_queue, cl_mem  buffer, int value, size_t pattern_size, size_t offset,size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event* event){$/;"	f
gmm_clEnqueueNDRangeKernel	core.c	/^cl_int gmm_clEnqueueNDRangeKernel(cl_command_queue command_queue, cl_kernel kernel,cl_uint work_dim,const size_t *global_work_offset,const size_t * global_work_size,const size_t * local_work_size, cl_uint num_events_in_wait_list, const cl_event * event_in_wait_list, cl_event *event)$/;"	f
gmm_clEnqueueReadBuffer	core.c	/^cl_int gmm_clEnqueueReadBuffer(cl_command_queue command_queue, cl_mem src, cl_bool blocking, size_t offset,size_t count, void * dst, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event*event){$/;"	f
gmm_clEnqueueTask	core.c	/^cl_int gmm_clEnqueueTask(cl_command_queue command_queue, cl_kernel kernel, cl_uint num_events_in_wait_list, const cl_event * event_in_wait_list, cl_event *event)$/;"	f
gmm_clEnqueueWriteBuffer	core.c	/^cl_int gmm_clEnqueueWriteBuffer(cl_command_queue command_queue, cl_mem dst, cl_bool blocking_write, size_t offset, size_t count, const void *src, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event* event){$/;"	f
gmm_clReleaseMemObject	core.c	/^cl_int gmm_clReleaseMemObject(cl_mem memObjPtr){$/;"	f
gmm_clSetKernelArg	core.c	/^cl_int gmm_clSetKernelArg(cl_kernel kernel,cl_uint offset,size_t size, const void* arg){$/;"	f
gmm_client	protocol.h	/^struct gmm_client {$/;"	s
gmm_context	core.h	/^struct gmm_context {$/;"	s
gmm_context_fini	core.c	/^void gmm_context_fini(){$/;"	f
gmm_context_init	core.c	/^int gmm_context_init(){$/;"	f
gmm_context_initEX	core.c	/^void gmm_context_initEX(){$/;"	f
gmm_dtod	core.c	/^static int gmm_dtod(struct region *rd,struct region *rs,cl_mem dst,cl_mem src,size_t count,size_t dst_off,size_t src_off)$/;"	f	file:
gmm_dtoh	core.c	/^int gmm_dtoh(struct region *r, void *dst, const cl_mem src, size_t count,size_t src_off)$/;"	f
gmm_dtoh_block	core.c	/^static int gmm_dtoh_block($/;"	f	file:
gmm_dtoh_pta	core.c	/^static int gmm_dtoh_pta($/;"	f	file:
gmm_dump_dptr	debug.c	/^void gmm_dump_dptr(const char *filepath, const void *dptr, const size_t size)$/;"	f
gmm_dump_region	debug.c	/^void gmm_dump_region($/;"	f
gmm_evict	core.c	/^static int gmm_evict(long size_needed, struct region **excls, int nexcl)$/;"	f	file:
gmm_fini	interfaces.c	/^void gmm_fini(void)$/;"	f
gmm_flags	core.h	/^	int gmm_flags;$/;"	m	struct:region
gmm_free	core.c	/^static int gmm_free(struct region *r){$/;"	f	file:
gmm_global	protocol.h	/^struct gmm_global {$/;"	s
gmm_htod	core.c	/^static int gmm_htod($/;"	f	file:
gmm_htod_block	core.c	/^static int gmm_htod_block($/;"	f	file:
gmm_htod_pta	core.c	/^static int gmm_htod_pta($/;"	f	file:
gmm_init	interfaces.c	/^void gmm_init(void)$/;"	f
gmm_kernel_callback	core.c	/^void CL_CALLBACK gmm_kernel_callback(cl_event event,cl_int status, void *data){$/;"	f
gmm_launch	core.c	/^static int gmm_launch(struct region **rgns, int nrgns,cl_kernel kernel)$/;"	f	file:
gmm_launch2	core.c	/^static int gmm_launch2(struct region **rgns, int nrgns,cl_kernel kernel,cl_uint work_dim,const size_t*global_work_offset, const size_t * global_work_size, const size_t* local_work_size, cl_event* event)$/;"	f	file:
gmm_load	core.c	/^static int gmm_load(struct region **rgns, int nrgns)$/;"	f	file:
gmm_memcpy_dtoh	core.c	/^static int gmm_memcpy_dtoh(void* dst, cl_mem src, unsigned long size,int prev_off)$/;"	f	file:
gmm_memcpy_htod	core.c	/^static int gmm_memcpy_htod(cl_mem dst,const void * src, unsigned long size,int prev_off){$/;"	f	file:
gmm_memset	core.c	/^static int gmm_memset(struct region *r, cl_mem buffer,int value, size_t count){$/;"	f	file:
gmm_memset_pta	core.c	/^static int gmm_memset_pta(struct region * r, cl_mem dst, int value, size_t count){$/;"	f	file:
gmm_print_dptr	debug.c	/^void gmm_print_dptr(const void *dptr)$/;"	f
gmm_print_region	debug.c	/^void gmm_print_region(void *rgn)$/;"	f
gprint	common.h	32;"	d
gprint	common.h	48;"	d
gprint_buffer	common.c	/^char *gprint_buffer = NULL;$/;"	v
gprint_fini	common.c	/^void gprint_fini()$/;"	f
gprint_head	common.c	/^int gprint_head = 0;$/;"	v
gprint_init	common.c	/^void gprint_init()$/;"	f
gprint_lines	common.c	/^int gprint_lines = 0;$/;"	v
gprint_lock	common.c	/^struct spinlock gprint_lock;$/;"	v	typeref:struct:spinlock
handle_rep_ack	msq.c	/^void handle_rep_ack(struct msg_rep *msg)$/;"	f
handle_req_evict	msq.c	/^void handle_req_evict(struct msg_req *msg)$/;"	f
ibuf	core.h	/^	int ibuf;					\/\/ The next staging buffer to be used$/;"	m	struct:dma_channel
ilru	protocol.h	/^	int ilru;$/;"	m	struct:gmm_global
imru	protocol.h	/^	int imru;$/;"	m	struct:gmm_global
index	protocol.h	/^	int index;					\/\/ index of this client; -1 means unoccupied$/;"	m	struct:gmm_client
inext	protocol.h	/^	int inext;					\/\/ index of the next client in the LRU list$/;"	m	struct:gmm_client
info	server.c	/^int info()$/;"	f
initialized	interfaces.c	/^static int initialized = 0;$/;"	v	file:
initlock	spinlock.h	/^static inline void initlock(struct spinlock *lk)$/;"	f
iprev	protocol.h	/^	int iprev;					\/\/ index of the previous client in the LRU list$/;"	m	struct:gmm_client
is_client_local	client.c	/^int is_client_local(int client)$/;"	f
is_dptr	core.h	/^	char is_dptr;$/;"	m	struct:karg
is_included	core.h	/^static inline int is_included(void **a, int n, void *p)$/;"	f
karg	core.h	/^struct karg {$/;"	s
kargs	core.c	/^static struct karg kargs[NREFS];$/;"	v	typeref:struct:karg	file:
kcb	core.h	/^struct kcb {$/;"	s
kstack	core.c	/^static unsigned char kstack[512];$/;"	v	file:
ktop	core.c	/^static void *ktop=(void *)kstack;$/;"	v	file:
latomic_add	atomic.h	/^static inline long latomic_add(latomic_t *ptr, long val)$/;"	f
latomic_dec	atomic.h	/^static inline long latomic_dec(latomic_t *ptr)$/;"	f
latomic_inc	atomic.h	/^static inline long latomic_inc(latomic_t *ptr)$/;"	f
latomic_read	atomic.h	/^static inline int latomic_read(latomic_t *ptr)$/;"	f
latomic_set	atomic.h	/^static inline void latomic_set(latomic_t *ptr, long val)$/;"	f
latomic_sub	atomic.h	/^static inline long latomic_sub(latomic_t *ptr, long val)$/;"	f
latomic_t	atomic.h	/^typedef volatile long latomic_t;$/;"	t
launch_signal	client.c	/^void launch_signal()$/;"	f
launch_wait	client.c	/^void launch_wait()$/;"	f
list_add	list.h	/^static inline void list_add(struct list_head *add, struct list_head *head)$/;"	f
list_add_tail	list.h	/^static inline void list_add_tail(struct list_head *add, struct list_head *head)$/;"	f
list_alloced	core.h	/^	struct list_head list_alloced;		\/\/ List of all allocated mem regions$/;"	m	struct:gmm_context	typeref:struct:gmm_context::list_head
list_alloced_add	core.c	/^static void list_alloced_add(struct gmm_context *ctx, struct region *r)$/;"	f	file:
list_alloced_del	core.c	/^static void list_alloced_del(struct gmm_context *ctx, struct region *r)$/;"	f	file:
list_attached	core.h	/^	struct list_head list_attached;		\/\/ LRU list of attached mem regions$/;"	m	struct:gmm_context	typeref:struct:gmm_context::list_head
list_attached_add	core.c	/^static void list_attached_add(struct gmm_context *ctx, struct region *r)$/;"	f	file:
list_attached_del	core.c	/^static void list_attached_del(struct gmm_context *ctx, struct region *r)$/;"	f	file:
list_attached_mov	core.c	/^static void list_attached_mov(struct gmm_context *ctx, struct region *r)$/;"	f	file:
list_del	list.h	/^static inline void list_del(struct list_head *entry)$/;"	f
list_empty	list.h	/^static inline int list_empty(const struct list_head *head)$/;"	f
list_entry	list.h	93;"	d
list_for_each	list.h	77;"	d
list_for_each_prev	list.h	81;"	d
list_head	list.h	/^struct list_head {$/;"	s
list_move	list.h	/^static inline void list_move(struct list_head *list, struct list_head *head)$/;"	f
list_move_tail	list.h	/^static inline void list_move_tail($/;"	f
local_victim_evict	core.c	/^long local_victim_evict(long size_needed)$/;"	f
lock	core.h	/^	struct spinlock lock;				\/\/ TODO: what's the use of this lock??$/;"	m	struct:gmm_context	typeref:struct:gmm_context::spinlock
lock	core.h	/^	struct spinlock lock;	\/\/ r\/w lock$/;"	m	struct:block	typeref:struct:block::spinlock
lock	core.h	/^	struct spinlock lock;	\/\/ the lock that protects memory object state$/;"	m	struct:region	typeref:struct:region::spinlock
lock	core.h	/^	struct spinlock lock;$/;"	m	struct:dma_channel	typeref:struct:dma_channel::spinlock
lock	protocol.h	/^	struct spinlock lock;		\/\/ This lock works only when the hardware cache$/;"	m	struct:gmm_global	typeref:struct:gmm_global::spinlock
lock	stats.h	/^	struct spinlock lock;$/;"	m	struct:statistics	typeref:struct:statistics::spinlock
lock_alloced	core.h	/^	struct spinlock lock_alloced;$/;"	m	struct:gmm_context	typeref:struct:gmm_context::spinlock
lock_attached	core.h	/^	struct spinlock lock_attached;$/;"	m	struct:gmm_context	typeref:struct:gmm_context::spinlock
locked	spinlock.h	/^	unsigned int locked;$/;"	m	struct:spinlock
main	oclTest/fptr.c	/^int main(){$/;"	f
main	oclTest/newT.c	/^int main(){$/;"	f
main	oclTest/test.c	/^int main(){$/;"	f
main	server.c	/^int main(int argc, char *argv[])$/;"	f
mem_total	protocol.h	/^	long mem_total;				\/\/ Total size of device memory.$/;"	m	struct:gmm_global
mem_used	protocol.h	/^	latomic_t mem_used;			\/\/ Size of used (attached) device memory$/;"	m	struct:gmm_global
memsize_free	client.c	/^long memsize_free()$/;"	f
memsize_free2	client.c	/^long memsize_free2()$/;"	f
memsize_getUsed	client.c	/^long memsize_getUsed(){$/;"	f
memsize_total	client.c	/^long memsize_total()$/;"	f
mqid	msq.c	/^mqd_t mqid = (mqd_t) -1;$/;"	v
msg	protocol.h	/^struct msg {$/;"	s
msg_rep	protocol.h	/^struct msg_rep {$/;"	s
msg_req	protocol.h	/^struct msg_req {$/;"	s
msgtype	protocol.h	/^enum msgtype {$/;"	g
msq_fini	msq.c	/^void msq_fini()$/;"	f
msq_init	msq.c	/^int msq_init()$/;"	f
msq_send	msq.c	/^int msq_send(int client, const struct msg *msg)$/;"	f
msq_send_rep_ack	msq.c	/^int msq_send_rep_ack(int client, long ack)$/;"	f
msq_send_req_evict	msq.c	/^long msq_send_req_evict(int client, long size_needed, int block)$/;"	f
mutx_ack	msq.c	/^pthread_mutex_t mutx_ack;$/;"	v
nargs	core.c	/^static int nargs=0;$/;"	v	file:
nclients	protocol.h	/^	int nclients;$/;"	m	struct:gmm_global
ndptr_arg	core.h	/^struct ndptr_arg {$/;"	s
next	list.h	/^	struct list_head *next;$/;"	m	struct:list_head	typeref:struct:list_head::list_head
nrefs	interfaces.c	/^int nrefs=0;$/;"	v
nrgns	core.h	/^	int nrgns;					\/\/ Number of regions referenced$/;"	m	struct:kcb
ocl_clBuildProgram	interfaces.c	/^cl_int (*ocl_clBuildProgram)(cl_program, cl_uint, const cl_device_id*, const char *, void *,void*)=NULL;$/;"	v
ocl_clCreateBuffer	interfaces.c	/^cl_mem (*ocl_clCreateBuffer)(cl_context, cl_mem_flags, size_t, void*, cl_int)= NULL;$/;"	v
ocl_clCreateContext	interfaces.c	/^cl_context (*ocl_clCreateContext)(cl_context_properties *,cl_uint ,const cl_device_id *,void*, void *,cl_int *)=NULL;$/;"	v
ocl_clCreateProgramWithSource	interfaces.c	/^cl_program (*ocl_clCreateProgramWithSource)(cl_context, cl_uint, const char**, const size_t *, cl_int *errcode_ret)=NULL;$/;"	v
ocl_clEnqueueCopyBuffer	interfaces.c	/^cl_int (*ocl_clEnqueueCopyBuffer)(cl_command_queue,cl_mem,cl_mem,size_t,size_t,size_t,cl_uint,const cl_event*,cl_event)=NULL;$/;"	v
ocl_clEnqueueFillBuffer	interfaces.c	/^cl_int (*ocl_clEnqueueFillBuffer)(cl_command_queue, cl_mem, const void *, size_t, size_t,size_t, cl_uint, const cl_event, cl_event)=NULL;$/;"	v
ocl_clEnqueueNDRangeKernel	interfaces.c	/^cl_int (*ocl_clEnqueueNDRangeKernel)(cl_command_queue,cl_kernel,cl_uint,const size_t*,const size_t *,const size_t *,cl_uint, const cl_event*,cl_event*)=NULL;$/;"	v
ocl_clEnqueueReadBuffer	interfaces.c	/^cl_int (*ocl_clEnqueueReadBuffer)(cl_command_queue, cl_mem, cl_bool, size_t, size_t , const void*, cl_uint, const cl_event *, cl_event*)=NULL;$/;"	v
ocl_clEnqueueTask	interfaces.c	/^cl_int (*ocl_clEnqueueTask)(cl_command_queue, cl_kernel, cl_uint, const cl_event*, cl_event *)=NULL;$/;"	v
ocl_clEnqueueWriteBuffer	interfaces.c	/^cl_int (*ocl_clEnqueueWriteBuffer)(cl_command_queue, cl_mem, cl_bool, size_t, size_t , const void*, cl_uint, const cl_event *, cl_event*)=NULL;$/;"	v
ocl_clReleaseMemObject	interfaces.c	/^cl_int (*ocl_clReleaseMemObject)(cl_mem)= NULL;$/;"	v
ocl_clSetKernelArg	interfaces.c	/^cl_int (*ocl_clSetKernelArg)(cl_kernel, cl_uint,size_t, const void* arg_value)=NULL;$/;"	v
off	core.h	/^	unsigned long off;		\/\/ device pointer offset in the region$/;"	m	struct:dptr_arg
panic	common.c	/^void panic(char *msg)$/;"	f
pcontext	core.c	/^struct gmm_context *pcontext=NULL;$/;"	v	typeref:struct:gmm_context
pglobal	client.c	/^struct gmm_global *pglobal = NULL;	\/\/ Global shared memory$/;"	v	typeref:struct:gmm_global
pid	protocol.h	/^	pid_t pid;$/;"	m	struct:gmm_client
pinned	core.h	/^	atomic_t pinned;		\/\/ atomic pin counter$/;"	m	struct:region
pinned	protocol.h	/^	int pinned;$/;"	m	struct:gmm_client
platform	core.h	/^    cl_platform_id *platform;$/;"	m	struct:gmm_context
prev	list.h	/^	struct list_head *prev;$/;"	m	struct:list_head	typeref:struct:list_head::list_head
program_kernel	core.h	/^    cl_program program_kernel;$/;"	m	struct:gmm_context
pta_addr	core.h	/^	void* pta_addr;			\/\/ dptr array address$/;"	m	struct:region
r	core.h	/^	struct region *r;		\/\/ for a local victim$/;"	m	struct:victim	typeref:struct:victim::region
r	core.h	/^	struct region *r;		\/\/ the region this argument points to$/;"	m	struct:dptr_arg	typeref:struct:dptr_arg::region
reading	core.h	/^	atomic_t reading;		\/\/ being read by how many kernels$/;"	m	struct:region
refs	interfaces.c	/^int refs[NREFS];$/;"	v
region	core.h	/^struct region {$/;"	s
region_attach	core.c	/^static int region_attach($/;"	f	file:
region_evict	core.c	/^long region_evict(struct region *r)$/;"	f
region_inval	core.h	/^static inline void region_inval(struct region *r, int swp)$/;"	f
region_load	core.c	/^static int region_load(struct region *r)$/;"	f	file:
region_load_cow	core.c	/^static int region_load_cow(struct region *r)$/;"	f	file:
region_load_memset	core.c	/^static int region_load_memset(struct region *r)$/;"	f	file:
region_load_pta	core.c	/^static int region_load_pta(struct region *r)$/;"	f	file:
region_lookup	core.c	/^struct region * region_lookup(struct gmm_context *ctx, const cl_mem ptr){$/;"	f
region_pin	core.c	/^static inline void region_pin(struct region *r)$/;"	f	file:
region_pinned	core.h	158;"	d
region_state	core.h	/^typedef enum region_state {$/;"	g
region_state_t	core.h	/^} region_state_t;$/;"	t	typeref:enum:region_state
region_unpin	core.c	/^static inline void region_unpin(struct region *r)$/;"	f	file:
region_valid	core.h	/^static inline void region_valid(struct region *r, int swp)$/;"	f
regions_referenced	core.c	/^static long regions_referenced(struct region ***prgns, int *pnrgns)$/;"	f	file:
release	spinlock.h	/^static inline void release(struct spinlock *lk)$/;"	f
remote_victim_evict	core.c	/^long remote_victim_evict(int client, long size_needed)$/;"	f
restart	server.c	/^int restart(size_t mem_total)$/;"	f
ret	protocol.h	/^	long ret;$/;"	m	struct:msg_rep
rgns	core.h	/^	struct region *rgns[NREFS];	\/\/ Regions referenced by the kernel$/;"	m	struct:kcb	typeref:struct:kcb::region
rwflags	interfaces.c	/^int rwflags[NREFS];$/;"	v
rwhint	core.h	/^	struct rwhint rwhint;	\/\/ rw hint$/;"	m	struct:region	typeref:struct:region::rwhint
rwhint	core.h	/^struct rwhint {$/;"	s
sem_launch	client.c	/^sem_t *sem_launch = SEM_FAILED;		\/\/ Guarding kernel launches$/;"	v
show_stackframe	common.c	/^static void show_stackframe() {$/;"	f	file:
size	core.h	/^	size_t size;$/;"	m	struct:karg
size	core.h	/^	unsigned long size;				\/\/ size of the object in bytes$/;"	m	struct:region
size	protocol.h	/^	int size;$/;"	m	struct:msg
size	protocol.h	/^	int size;$/;"	m	struct:msg_rep
size	protocol.h	/^	int size;$/;"	m	struct:msg_req
size_attached	core.h	/^	latomic_t size_attached;			\/\/ Total size of attached mem regions$/;"	m	struct:gmm_context
size_detachable	protocol.h	/^	latomic_t size_detachable;$/;"	m	struct:gmm_client
size_needed	protocol.h	/^	long size_needed;$/;"	m	struct:msg_req
spinlock	spinlock.h	/^struct spinlock {$/;"	s
stage_bufs	core.h	/^	cl_mem stage_bufs[NBUFS];	\/\/ Host-pinned staging buffers$/;"	m	struct:dma_channel
start	server.c	/^int start(size_t mem_total)$/;"	f
state	core.h	/^	region_state_t state;	\/\/ state of the object$/;"	m	struct:region
statistics	stats.h	/^struct statistics {$/;"	s
stats	core.h	/^	struct statistics stats;$/;"	m	struct:gmm_context	typeref:struct:gmm_context::statistics
stats_inc	stats.h	128;"	d
stats_inc	stats.h	78;"	d
stats_inc_alloc	stats.h	126;"	d
stats_inc_alloc	stats.h	60;"	d
stats_inc_freed	stats.h	127;"	d
stats_inc_freed	stats.h	70;"	d
stats_init	stats.c	/^void stats_init(struct statistics *pstats)$/;"	f
stats_kernel_end	stats.h	115;"	d
stats_kernel_end	stats.h	133;"	d
stats_kernel_start	stats.h	110;"	d
stats_kernel_start	stats.h	132;"	d
stats_print	stats.c	/^void stats_print(struct statistics *pstats)$/;"	f
stats_record_time	stats.h	131;"	d
stats_record_time	stats.h	99;"	d
stats_time_begin	stats.h	129;"	d
stats_time_begin	stats.h	87;"	d
stats_time_end	stats.h	130;"	d
stats_time_end	stats.h	92;"	d
stop	server.c	/^int stop()$/;"	f
swp_addr	core.h	/^	void* swp_addr;			\/\/ host swap buffer address$/;"	m	struct:region
swp_valid	core.h	/^	int swp_valid;			\/\/ if data copy in host swap buffer is valid$/;"	m	struct:block
testSize	oclTest/newT.c	13;"	d	file:
testSize	oclTest/test.c	13;"	d	file:
thread_msq_listener	msq.c	/^void *thread_msq_listener(void *arg)$/;"	f
tid_msq	msq.c	/^pthread_t tid_msq;$/;"	v
time_attach	stats.h	/^	double time_attach;			\/\/ Time on attaching (gmm_attach)$/;"	m	struct:statistics
time_d2s	stats.h	/^	double time_d2s;$/;"	m	struct:statistics
time_dtod	stats.h	/^	double time_dtod;$/;"	m	struct:statistics
time_dtoh	stats.h	/^	double time_dtoh;$/;"	m	struct:statistics
time_evict	stats.h	/^	double time_evict;			\/\/ Time on eviction (gmm_evict)$/;"	m	struct:statistics
time_htod	stats.h	/^	double time_htod;$/;"	m	struct:statistics
time_htod_cow	stats.h	/^	double time_htod_cow;$/;"	m	struct:statistics
time_kernel	stats.h	/^	double time_kernel;			\/\/ Time on kernel executions$/;"	m	struct:statistics
time_load	stats.h	/^	double time_load;			\/\/ Time on loading (gmm_load)$/;"	m	struct:statistics
time_memset	stats.h	/^	double time_memset;$/;"	m	struct:statistics
time_s2d	stats.h	/^	double time_s2d;$/;"	m	struct:statistics
time_s2u	stats.h	/^	double time_s2u;$/;"	m	struct:statistics
time_sync	stats.h	/^	double time_sync;			\/\/ Time on synchronizations$/;"	m	struct:statistics
time_u2d	stats.h	/^	double time_u2d;$/;"	m	struct:statistics
time_u2s	stats.h	/^	double time_u2s;$/;"	m	struct:statistics
try_acquire	spinlock.h	/^static inline int try_acquire(struct spinlock *lk)$/;"	f
type	protocol.h	/^	int type;$/;"	m	struct:msg
type	protocol.h	/^	int type;$/;"	m	struct:msg_rep
type	protocol.h	/^	int type;$/;"	m	struct:msg_req
update_attached	client.c	/^void update_attached(long delta)$/;"	f
update_detachable	client.c	/^void update_detachable(long delta)$/;"	f
usr_addr	core.h	/^	cl_mem usr_addr;			\/\/ copy-on-write user address$/;"	m	struct:region
value_memset	core.h	/^	int value_memset;		\/\/ value of cudaMemset$/;"	m	struct:region
verbose	server.c	/^int verbose = 0;$/;"	v
victim	core.h	/^struct victim {$/;"	s
victim_evict	core.c	/^long victim_evict(struct victim *victim, long size_needed)$/;"	f
victim_select	core.c	/^int victim_select($/;"	f
victim_select_lfu	replacement.c	/^int victim_select_lfu($/;"	f
victim_select_lru	replacement.c	/^int victim_select_lru($/;"	f
victim_select_lru_local	replacement.c	/^int victim_select_lru_local($/;"	f
writing	core.h	/^	atomic_t writing;		\/\/ being written by how many kernels$/;"	m	struct:region
xchg	spinlock.h	/^static inline unsigned int xchg($/;"	f
