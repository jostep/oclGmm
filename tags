!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
BUFSIZE	core.h	14;"	d
DEBUG	common.h	14;"	d
ERROR	common.h	11;"	d
FATAL	common.h	10;"	d
GBUFFER_SIZE	common.c	35;"	d	file:
GMM_EXPORT	common.h	7;"	d
GMM_PRINT_LEVEL	common.h	18;"	d
GMM_PRINT_MSG	common.c	/^char *GMM_PRINT_MSG[PRINT_LEVELS] = {$/;"	v
GMM_SEM_LAUNCH	protocol.h	74;"	d
GMM_SHM_GLOBAL	protocol.h	75;"	d
ILIST_ADD	protocol.h	/^static inline void ILIST_ADD(struct gmm_global *p, int inew)$/;"	f
ILIST_DEL	protocol.h	/^static inline void ILIST_DEL(struct gmm_global *p, int idel)$/;"	f
ILIST_MOV	protocol.h	/^static inline void ILIST_MOV(struct gmm_global *p, int imov)$/;"	f
INFO	common.h	13;"	d
INIT_LIST_HEAD	list.h	/^static inline void INIT_LIST_HEAD(struct list_head *list)$/;"	f
INTERCEPT_CL	interfaces.h	33;"	d
MSG_REP_ACK	protocol.h	/^	MSG_REP_ACK,$/;"	e	enum:msgtype
MSG_REQ_EVICT	protocol.h	/^	MSG_REQ_EVICT,$/;"	e	enum:msgtype
NBUFS	core.h	13;"	d
NCLIENTS	protocol.h	12;"	d
OFFSETOF	list.h	85;"	d
OPENCL_PATH	interfaces.h	16;"	d
PRINT_LEVELS	common.h	15;"	d
STAT	common.h	9;"	d
TDIFF	stats.h	53;"	d
TREAT_ERROR	interfaces.h	18;"	d
TRY_ACQUIRE_TIMES	spinlock.h	42;"	d
TVAL	stats.h	52;"	d
WARN	common.h	12;"	d
_GMM_ATOMIC_H_	atomic.h	2;"	d
_GMM_CLIENT_H_	client.h	2;"	d
_GMM_COMMON_H_	common.h	2;"	d
_GMM_CORE_H_	core.h	2;"	d
_GMM_INTERFACES_H_	interfaces.h	2;"	d
_GMM_LIST_H_	list.h	2;"	d
_GMM_MSQ_H_	msq.h	2;"	d
_GMM_PROTOCOL_H_	protocol.h	4;"	d
_GMM_SPINLOCK_H_	spinlock.h	3;"	d
_GMM_STATS_H_	stats.h	2;"	d
_GNU_SOURCE	common.h	60;"	d
__USE_GNU	interfaces.h	5;"	d
__list_add	list.h	/^static inline void __list_add($/;"	f
__list_del	list.h	/^static inline void __list_del(struct list_head * prev, struct list_head * next)$/;"	f
ack	msq.c	/^long ack = 0;	\/\/ it's meaning depends on the message;$/;"	v
acquire	spinlock.h	/^static inline void acquire(struct spinlock *lk)$/;"	f
atomic_add	atomic.h	/^static inline int atomic_add(atomic_t *ptr, int val)$/;"	f
atomic_dec	atomic.h	/^static inline int atomic_dec(atomic_t *ptr)$/;"	f
atomic_inc	atomic.h	/^static inline int atomic_inc(atomic_t *ptr)$/;"	f
atomic_read	atomic.h	/^static inline int atomic_read(atomic_t *ptr)$/;"	f
atomic_set	atomic.h	/^static inline void atomic_set(atomic_t *ptr, int val)$/;"	f
atomic_sub	atomic.h	/^static inline int atomic_sub(atomic_t *ptr, int val)$/;"	f
atomic_t	atomic.h	/^typedef volatile int atomic_t;$/;"	t
block	protocol.h	/^	int block;$/;"	m	struct:msg_req
blocks	core.h	/^    struct block *blocks;$/;"	m	struct:region	typeref:struct:region::block
bytes_d2s	stats.h	/^	long bytes_d2s;				\/\/ device to swap buffer$/;"	m	struct:statistics
bytes_dtod	stats.h	/^	long bytes_dtod;			\/\/ # of bytes going through the dtod API$/;"	m	struct:statistics
bytes_dtoh	stats.h	/^	long bytes_dtoh;			\/\/ # of bytes going through the dtoh API$/;"	m	struct:statistics
bytes_evict_needed	stats.h	/^	long bytes_evict_needed;	\/\/ # of bytes of free space required$/;"	m	struct:statistics
bytes_evict_space	stats.h	/^	long bytes_evict_space;		\/\/ # of bytes actually freed$/;"	m	struct:statistics
bytes_htod	stats.h	/^	long bytes_htod;			\/\/ # of bytes going through the htod API$/;"	m	struct:statistics
bytes_htod_cow	stats.h	/^	long bytes_htod_cow;		\/\/ # of htod bytes that are marked cow$/;"	m	struct:statistics
bytes_mem_active	stats.c	/^long bytes_mem_active = 0L;$/;"	v
bytes_mem_alloc	stats.h	/^	long bytes_mem_alloc;		\/\/ # of bytes allocated$/;"	m	struct:statistics
bytes_mem_freed	stats.h	/^	long bytes_mem_freed;		\/\/ # of bytes explicitly freed (detect leaks)$/;"	m	struct:statistics
bytes_mem_peak	stats.h	/^	long bytes_mem_peak;		\/\/ # of bytes held at peak$/;"	m	struct:statistics
bytes_memset	stats.h	/^	long bytes_memset;			\/\/ # of bytes going through the memset API$/;"	m	struct:statistics
bytes_s2d	stats.h	/^	long bytes_s2d;				\/\/ swap buffer to device$/;"	m	struct:statistics
bytes_s2u	stats.h	/^	long bytes_s2u;				\/\/ swap buffer to user buffer$/;"	m	struct:statistics
bytes_u2d	stats.h	/^	long bytes_u2d;				\/\/ user buffer to device, i.e. cow loading$/;"	m	struct:statistics
bytes_u2s	stats.h	/^	long bytes_u2s;				\/\/ user buffer to swap buffer$/;"	m	struct:statistics
cid	client.c	/^int cid = -1;						\/\/ Id of this client$/;"	v
cidtopid	client.c	/^pid_t cidtopid(int cid)$/;"	f
clCreateBuffer	interfaces.c	/^cl_mem clCreateBuffer(cl_context context, cl_mem_flags flags, size_t size, void *host_ptr, cl_int *errcode){$/;"	f
clReleaseMemObject	interfaces.c	/^cl_int clReleaseMemObject(cl_mem memObj){$/;"	f
client_alloc	client.c	/^static int client_alloc()$/;"	f	file:
client_attach	client.c	/^int client_attach()$/;"	f
client_detach	client.c	/^void client_detach() {$/;"	f
client_free	client.c	/^static void client_free(int id)$/;"	f	file:
client_lru_detachable	client.c	/^int client_lru_detachable()$/;"	f
client_unpin	client.c	/^void client_unpin(int client)$/;"	f
clients	protocol.h	/^	struct gmm_client clients[NCLIENTS];$/;"	m	struct:gmm_global	typeref:struct:gmm_global::gmm_client
commandQueue_chan	core.h	/^    cl_command_queue commandQueue_chan;\/\/stream$/;"	m	struct:dma_channel
commandQueue_kernel	core.h	/^    cl_command_queue commandQueue_kernel;$/;"	m	struct:gmm_context
cond_ack	msq.c	/^pthread_cond_t cond_ack;$/;"	v
context_kernel	core.h	/^    cl_context context_kernel;$/;"	m	struct:gmm_context
count_attach_fail	stats.h	/^	long count_attach_fail;		\/\/ # of failed attach$/;"	m	struct:statistics
count_evict_fail	stats.h	/^	long count_evict_fail;		\/\/ # of failed evictions in gmm_evict$/;"	m	struct:statistics
count_evict_victims	stats.h	/^	long count_evict_victims;	\/\/ # of evicted victim regions$/;"	m	struct:statistics
dev_addr	core.h	/^    cl_mem *dev_addr;$/;"	m	struct:region
device	core.h	/^    cl_device_id *device;$/;"	m	struct:gmm_context
dma_channel	core.h	/^struct dma_channel{$/;"	s
dma_channel_fini	core.c	/^static void dma_channel_fini(struct dma_channel *chan){$/;"	f	file:
dma_channel_init	core.c	/^static int dma_channel_init(struct dma_channel *chan, int htod){$/;"	f	file:
dma_dtoh	core.h	/^    struct dma_channel dma_dtoh;$/;"	m	struct:gmm_context	typeref:struct:gmm_context::dma_channel
dma_htod	core.h	/^    struct dma_channel dma_htod;$/;"	m	struct:gmm_context	typeref:struct:gmm_context::dma_channel
entry_alloced	core.h	/^    struct list_head entry_alloced;$/;"	m	struct:region	typeref:struct:region::list_head
entry_attached	core.h	/^    struct list_head entry_attached;$/;"	m	struct:region	typeref:struct:region::list_head
errcode	core.c	/^cl_int *errcode=NULL;$/;"	v
events	core.h	/^    cl_event events[NBUFS];$/;"	m	struct:dma_channel
flags	core.h	/^    cl_mem_flags flags;$/;"	m	struct:region
flags	core.h	/^    int flags;$/;"	m	struct:rwhint
from	protocol.h	/^	int from;$/;"	m	struct:msg_rep
from	protocol.h	/^	int from;$/;"	m	struct:msg_req
getcid	client.c	/^int getcid()$/;"	f
gettid	common.h	/^static inline pid_t gettid()$/;"	f
gmm_clCreateBuffer	core.c	/^cl_mem gmm_clCreateBuffer(cl_context context, cl_mem_flags flags, size_t size, void *host_ptr, cl_int* errcode_CB, int gmm_flags){$/;"	f
gmm_clReleaseMemObject	core.c	/^cl_int gmm_clReleaseMemObject(cl_mem *memObj){$/;"	f
gmm_client	protocol.h	/^struct gmm_client {$/;"	s
gmm_context	core.h	/^struct gmm_context{$/;"	s
gmm_context_fini	core.c	/^void gmm_context_fini(){$/;"	f
gmm_context_init	core.c	/^int gmm_context_init(){$/;"	f
gmm_fini	interfaces.c	/^void gmm_fini(void)$/;"	f
gmm_flags	core.h	/^    int gmm_flags;$/;"	m	struct:region
gmm_free	core.c	/^static int gmm_free(struct region *r){$/;"	f	file:
gmm_global	protocol.h	/^struct gmm_global {$/;"	s
gmm_init	interfaces.c	/^void gmm_init(void)$/;"	f
gprint	common.h	32;"	d
gprint	common.h	48;"	d
gprint_buffer	common.c	/^char *gprint_buffer = NULL;$/;"	v
gprint_fini	common.c	/^void gprint_fini()$/;"	f
gprint_head	common.c	/^int gprint_head = 0;$/;"	v
gprint_init	common.c	/^void gprint_init()$/;"	f
gprint_lines	common.c	/^int gprint_lines = 0;$/;"	v
gprint_lock	common.c	/^struct spinlock gprint_lock;$/;"	v	typeref:struct:spinlock
handle_rep_ack	msq.c	/^void handle_rep_ack(struct msg_rep *msg)$/;"	f
handle_req_evict	msq.c	/^void handle_req_evict(struct msg_req *msg)$/;"	f
ibuf	core.h	/^    int ibuf;$/;"	m	struct:dma_channel
ilru	protocol.h	/^	int ilru;$/;"	m	struct:gmm_global
imru	protocol.h	/^	int imru;$/;"	m	struct:gmm_global
index	protocol.h	/^	int index;					\/\/ index of this client; -1 means unoccupied$/;"	m	struct:gmm_client
inext	protocol.h	/^	int inext;					\/\/ index of the next client in the LRU list$/;"	m	struct:gmm_client
initialized	interfaces.c	/^static int initialized = 0;$/;"	v	file:
initlock	spinlock.h	/^static inline void initlock(struct spinlock *lk)$/;"	f
iprev	protocol.h	/^	int iprev;					\/\/ index of the previous client in the LRU list$/;"	m	struct:gmm_client
is_client_local	client.c	/^int is_client_local(int client)$/;"	f
latomic_add	atomic.h	/^static inline long latomic_add(latomic_t *ptr, long val)$/;"	f
latomic_dec	atomic.h	/^static inline long latomic_dec(latomic_t *ptr)$/;"	f
latomic_inc	atomic.h	/^static inline long latomic_inc(latomic_t *ptr)$/;"	f
latomic_read	atomic.h	/^static inline int latomic_read(latomic_t *ptr)$/;"	f
latomic_set	atomic.h	/^static inline void latomic_set(latomic_t *ptr, long val)$/;"	f
latomic_sub	atomic.h	/^static inline long latomic_sub(latomic_t *ptr, long val)$/;"	f
latomic_t	atomic.h	/^typedef volatile long latomic_t;$/;"	t
launch_signal	client.c	/^void launch_signal()$/;"	f
launch_wait	client.c	/^void launch_wait()$/;"	f
list_add	list.h	/^static inline void list_add(struct list_head *add, struct list_head *head)$/;"	f
list_add_tail	list.h	/^static inline void list_add_tail(struct list_head *add, struct list_head *head)$/;"	f
list_allocated	core.h	/^    struct list_head list_allocated;$/;"	m	struct:gmm_context	typeref:struct:gmm_context::list_head
list_alloced_add	core.c	/^static void list_alloced_add(struct gmm_context *ctx, struct region *r){$/;"	f	file:
list_attached	core.h	/^    struct list_head list_attached;$/;"	m	struct:gmm_context	typeref:struct:gmm_context::list_head
list_del	list.h	/^static inline void list_del(struct list_head *entry)$/;"	f
list_empty	list.h	/^static inline int list_empty(const struct list_head *head)$/;"	f
list_entry	list.h	88;"	d
list_for_each	list.h	72;"	d
list_for_each_prev	list.h	76;"	d
list_head	list.h	/^struct list_head {$/;"	s
list_move	list.h	/^static inline void list_move(struct list_head *list, struct list_head *head)$/;"	f
list_move_tail	list.h	/^static inline void list_move_tail($/;"	f
lock	core.h	/^    struct spinlock lock;$/;"	m	struct:dma_channel	typeref:struct:dma_channel::spinlock
lock	core.h	/^    struct spinlock lock;$/;"	m	struct:gmm_context	typeref:struct:gmm_context::spinlock
lock	core.h	/^    struct spinlock lock;$/;"	m	struct:region	typeref:struct:region::spinlock
lock	protocol.h	/^	struct spinlock lock;		\/\/ This lock works only when the hardware cache$/;"	m	struct:gmm_global	typeref:struct:gmm_global::spinlock
lock	stats.h	/^	struct spinlock lock;$/;"	m	struct:statistics	typeref:struct:statistics::spinlock
lock_alloced	core.h	/^    struct spinlock lock_alloced;$/;"	m	struct:gmm_context	typeref:struct:gmm_context::spinlock
lock_attached	core.h	/^    struct spinlock lock_attached;$/;"	m	struct:gmm_context	typeref:struct:gmm_context::spinlock
locked	spinlock.h	/^	unsigned int locked;$/;"	m	struct:spinlock
mem_total	protocol.h	/^	long mem_total;				\/\/ Total size of device memory.$/;"	m	struct:gmm_global
mem_used	protocol.h	/^	latomic_t mem_used;			\/\/ Size of used (attached) device memory$/;"	m	struct:gmm_global
memsize_free	client.c	/^long memsize_free()$/;"	f
memsize_free2	client.c	/^long memsize_free2()$/;"	f
memsize_total	client.c	/^long memsize_total()$/;"	f
mqid	msq.c	/^mqd_t mqid = (mqd_t) -1;$/;"	v
msg	protocol.h	/^struct msg {$/;"	s
msg_rep	protocol.h	/^struct msg_rep {$/;"	s
msg_req	protocol.h	/^struct msg_req {$/;"	s
msgtype	protocol.h	/^enum msgtype {$/;"	g
msq_fini	msq.c	/^void msq_fini()$/;"	f
msq_init	msq.c	/^int msq_init()$/;"	f
msq_send	msq.c	/^int msq_send(int client, const struct msg *msg)$/;"	f
msq_send_rep_ack	msq.c	/^int msq_send_rep_ack(int client, long ack)$/;"	f
msq_send_req_evict	msq.c	/^long msq_send_req_evict(int client, long size_needed, int block)$/;"	f
mutx_ack	msq.c	/^pthread_mutex_t mutx_ack;$/;"	v
nclients	protocol.h	/^	int nclients;$/;"	m	struct:gmm_global
next	list.h	/^	struct list_head *next;$/;"	m	struct:list_head	typeref:struct:list_head::list_head
ocl_clCreateBuffer	interfaces.c	/^cl_mem (*ocl_clCreateBuffer)(cl_context, cl_mem_flags, size_t, void*, cl_int)= NULL;$/;"	v
ocl_clReleaseMemObject	interfaces.c	/^cl_int (*ocl_clReleaseMemObject)(cl_mem)= NULL;$/;"	v
panic	common.c	/^void panic(char *msg)$/;"	f
pcontext	core.c	/^struct gmm_context *pcontext=NULL;$/;"	v	typeref:struct:gmm_context
pglobal	client.c	/^struct gmm_global *pglobal = NULL;	\/\/ Global shared memory$/;"	v	typeref:struct:gmm_global
pid	protocol.h	/^	pid_t pid;$/;"	m	struct:gmm_client
pinned	core.h	/^    atomic_t pinned;$/;"	m	struct:region
pinned	protocol.h	/^	int pinned;$/;"	m	struct:gmm_client
platform	core.h	/^    cl_platform_id platform;$/;"	m	struct:gmm_context
prev	list.h	/^	struct list_head *prev;$/;"	m	struct:list_head	typeref:struct:list_head::list_head
pta_addr	core.h	/^    cl_mem *pta_addr;$/;"	m	struct:region
reading	core.h	/^    atomic_t reading;$/;"	m	struct:region
region	core.h	/^struct region{$/;"	s
region_lookup	core.c	/^struct region * region_lookup(struct gmm_context *ctx, const cl_mem *ptr){$/;"	f
region_pinned	core.h	15;"	d
release	spinlock.h	/^static inline void release(struct spinlock *lk)$/;"	f
ret	protocol.h	/^	long ret;$/;"	m	struct:msg_rep
rwhint	core.h	/^    struct rwhint rwhint;$/;"	m	struct:region	typeref:struct:region::rwhint
rwhint	core.h	/^struct rwhint{$/;"	s
sem_launch	client.c	/^sem_t *sem_launch = SEM_FAILED;		\/\/ Guarding kernel launches$/;"	v
show_stackframe	common.c	/^static void show_stackframe() {$/;"	f	file:
size	core.h	/^    long size;$/;"	m	struct:region
size	protocol.h	/^	int size;$/;"	m	struct:msg
size	protocol.h	/^	int size;$/;"	m	struct:msg_rep
size	protocol.h	/^	int size;$/;"	m	struct:msg_req
size_detachable	protocol.h	/^	latomic_t size_detachable;$/;"	m	struct:gmm_client
size_needed	protocol.h	/^	long size_needed;$/;"	m	struct:msg_req
spinlock	spinlock.h	/^struct spinlock {$/;"	s
stage_bufs	core.h	/^    void *stage_bufs[NBUFS];$/;"	m	struct:dma_channel
state	core.h	/^    region_state_t state;$/;"	m	struct:region
statistics	stats.h	/^struct statistics {$/;"	s
stats	core.h	/^    struct statistics stats;$/;"	m	struct:gmm_context	typeref:struct:gmm_context::statistics
stats_inc	stats.h	128;"	d
stats_inc	stats.h	78;"	d
stats_inc_alloc	stats.h	126;"	d
stats_inc_alloc	stats.h	60;"	d
stats_inc_freed	stats.h	127;"	d
stats_inc_freed	stats.h	70;"	d
stats_init	stats.c	/^void stats_init(struct statistics *pstats)$/;"	f
stats_kernel_end	stats.h	115;"	d
stats_kernel_end	stats.h	133;"	d
stats_kernel_start	stats.h	110;"	d
stats_kernel_start	stats.h	132;"	d
stats_print	stats.c	/^void stats_print(struct statistics *pstats)$/;"	f
stats_record_time	stats.h	131;"	d
stats_record_time	stats.h	99;"	d
stats_time_begin	stats.h	129;"	d
stats_time_begin	stats.h	87;"	d
stats_time_end	stats.h	130;"	d
stats_time_end	stats.h	92;"	d
swp_addr	core.h	/^    cl_mem *swp_addr;$/;"	m	struct:region
thread_msq_listener	msq.c	/^void *thread_msq_listener(void *arg)$/;"	f
tid_msq	msq.c	/^pthread_t tid_msq;$/;"	v
time_attach	stats.h	/^	double time_attach;			\/\/ Time on attaching (gmm_attach)$/;"	m	struct:statistics
time_d2s	stats.h	/^	double time_d2s;$/;"	m	struct:statistics
time_dtod	stats.h	/^	double time_dtod;$/;"	m	struct:statistics
time_dtoh	stats.h	/^	double time_dtoh;$/;"	m	struct:statistics
time_evict	stats.h	/^	double time_evict;			\/\/ Time on eviction (gmm_evict)$/;"	m	struct:statistics
time_htod	stats.h	/^	double time_htod;$/;"	m	struct:statistics
time_htod_cow	stats.h	/^	double time_htod_cow;$/;"	m	struct:statistics
time_kernel	stats.h	/^	double time_kernel;			\/\/ Time on kernel executions$/;"	m	struct:statistics
time_load	stats.h	/^	double time_load;			\/\/ Time on loading (gmm_load)$/;"	m	struct:statistics
time_memset	stats.h	/^	double time_memset;$/;"	m	struct:statistics
time_s2d	stats.h	/^	double time_s2d;$/;"	m	struct:statistics
time_s2u	stats.h	/^	double time_s2u;$/;"	m	struct:statistics
time_sync	stats.h	/^	double time_sync;			\/\/ Time on synchronizations$/;"	m	struct:statistics
time_u2d	stats.h	/^	double time_u2d;$/;"	m	struct:statistics
time_u2s	stats.h	/^	double time_u2s;$/;"	m	struct:statistics
try_acquire	spinlock.h	/^static inline int try_acquire(struct spinlock *lk)$/;"	f
type	protocol.h	/^	int type;$/;"	m	struct:msg
type	protocol.h	/^	int type;$/;"	m	struct:msg_rep
type	protocol.h	/^	int type;$/;"	m	struct:msg_req
update_attached	client.c	/^void update_attached(long delta)$/;"	f
update_detachable	client.c	/^void update_detachable(long delta)$/;"	f
usr_addr	core.h	/^    cl_mem *usr_addr;$/;"	m	struct:region
value_memset	core.h	/^    int  value_memset;$/;"	m	struct:region
writing	core.h	/^    atomic_t writing;$/;"	m	struct:region
xchg	spinlock.h	/^static inline unsigned int xchg($/;"	f
